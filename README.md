# Complete Single README.md File

## Copy Everything Below Into Your README.md:

---

```markdown
# ğŸ¤– Complete AI/ML Mastery Roadmap
## From .NET Developer to AI/ML Expert | 18-Month Professional Guide

![Banner](https://img.shields.io/badge/ğŸš€-AI%2FML%20Journey-blue?style=for-the-badge)
![Progress](https://img.shields.io/badge/Progress-0%25-red?style=flat-square)
![Phase](https://img.shields.io/badge/Phase-Beginner-green?style=flat-square)
![Duration](https://img.shields.io/badge/Duration-18%20Months-orange?style=flat-square)
![Last Updated](https://img.shields.io/badge/Updated-2024-blue?style=flat-square)

---

## ğŸ“‹ Table of Contents

1. [Introduction](#-introduction)
2. [Why This Roadmap](#-why-this-roadmap)
3. [Prerequisites](#-prerequisites)
4. [Roadmap Overview](#-roadmap-overview)
5. [BEGINNER LEVEL (Month 1-6)](#-beginner-level-month-1-6)
   - [Month 1: Mathematics Foundation](#month-1-mathematics-foundation)
   - [Month 2: Python Programming](#month-2-python-programming)
   - [Month 3: Data Analysis & Visualization](#month-3-data-analysis--visualization)
   - [Month 4: Machine Learning Fundamentals](#month-4-machine-learning-fundamentals)
   - [Month 5: Advanced ML Techniques](#month-5-advanced-ml-techniques)
   - [Month 6: ML Projects & Consolidation](#month-6-ml-projects--consolidation)
6. [ADVANCED LEVEL (Month 7-12)](#-advanced-level-month-7-12)
   - [Month 7: Deep Learning Foundation](#month-7-deep-learning-foundation)
   - [Month 8: Computer Vision (CNN)](#month-8-computer-vision-cnn)
   - [Month 9: Natural Language Processing](#month-9-natural-language-processing)
   - [Month 10: Transformers & BERT](#month-10-transformers--bert)
   - [Month 11: Large Language Models](#month-11-large-language-models)
   - [Month 12: Generative AI & Advanced Topics](#month-12-generative-ai--advanced-topics)
7. [PROFESSIONAL LEVEL (Month 13-18)](#-professional-level-month-13-18)
   - [Month 13: MLOps Fundamentals](#month-13-mlops-fundamentals)
   - [Month 14: Cloud & Deployment](#month-14-cloud--deployment)
   - [Month 15: Azure AI & .NET Integration](#month-15-azure-ai--net-integration)
   - [Month 16: Enterprise AI Solutions](#month-16-enterprise-ai-solutions)
   - [Month 17: Specialization & Portfolio](#month-17-specialization--portfolio)
   - [Month 18: Job Preparation](#month-18-job-preparation)
8. [Projects Portfolio](#-projects-portfolio)
9. [Code Templates & Snippets](#-code-templates--snippets)
10. [Resources & Learning Materials](#-resources--learning-materials)
11. [Interview Preparation](#-interview-preparation)
12. [Progress Tracking](#-progress-tracking)
13. [FAQ](#-faq)
14. [Contributing](#-contributing)

---

# ğŸ¯ Introduction

Welcome to the most comprehensive AI/ML learning roadmap designed specifically for developers transitioning into AI/ML engineering. This guide provides a structured 18-month journey from complete beginner to professional AI/ML expert.

### What You'll Achieve

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         YOUR TRANSFORMATION                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚   START                           FINISH                                 â”‚
â”‚   â”€â”€â”€â”€â”€                           â”€â”€â”€â”€â”€â”€                                 â”‚
â”‚   .NET Developer          â†’       AI/ML Engineer                         â”‚
â”‚   No ML Experience        â†’       Production ML Systems                  â”‚
â”‚   No Python               â†’       Python Expert                          â”‚
â”‚   No Deep Learning        â†’       CNN, NLP, LLM Expert                   â”‚
â”‚   No MLOps                â†’       Full MLOps Pipeline                    â”‚
â”‚                                                                          â”‚
â”‚   SALARY POTENTIAL: $120K - $200K+ (2026)                               â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### End Goals Checklist

- [ ] Master Python for Data Science & ML
- [ ] Understand mathematics behind ML algorithms
- [ ] Build & train ML models from scratch
- [ ] Create deep learning solutions (CNN, RNN, Transformers)
- [ ] Work with LLMs & Generative AI
- [ ] Implement production MLOps pipelines
- [ ] Deploy models to cloud (Azure, AWS)
- [ ] Integrate AI with .NET applications
- [ ] Build 15+ impressive portfolio projects
- [ ] Be job-ready for AI/ML Engineer roles

---

# ğŸ’¡ Why This Roadmap

### Designed for Developers

| Your Background | How This Helps |
|-----------------|----------------|
| Strong in C#/.NET | Leverage coding skills, faster Python learning |
| OOP Experience | Easy transition to ML frameworks |
| Software Engineering | MLOps comes naturally |
| Problem Solving | Algorithm understanding is easier |

### Why AI/ML in 2026?

```
ğŸ“ˆ Market Demand:
   â€¢ AI/ML job growth: 40% annually
   â€¢ Average salary increase: 35-50%
   â€¢ Remote opportunities: 80%+
   
ğŸ¢ Industry Adoption:
   â€¢ Every company needs AI
   â€¢ LLMs transforming everything
   â€¢ Automation is accelerating
   
ğŸ’° Salary Ranges (2026):
   â€¢ Junior AI/ML Engineer: $90K - $120K
   â€¢ Mid-Level AI/ML Engineer: $130K - $170K
   â€¢ Senior AI/ML Engineer: $170K - $220K
   â€¢ AI Architect: $200K - $300K+
```

---

# ğŸ“š Prerequisites

### Required Before Starting

| Requirement | Details | Check |
|-------------|---------|-------|
| Programming Experience | Any language (you have C#) | âœ… |
| Basic Math | High school algebra | âœ… |
| Computer | 8GB+ RAM, GPU recommended | â¬œ |
| Time Commitment | 2-4 hours/day | â¬œ |
| Motivation | Strong desire to learn | â¬œ |

### Setup Checklist

- [ ] Install Python 3.10+
- [ ] Install VS Code or PyCharm
- [ ] Install Anaconda/Miniconda
- [ ] Create GitHub account
- [ ] Create Kaggle account
- [ ] Create Google Colab account (free GPU)
- [ ] Join AI/ML Discord communities

### Environment Setup

```bash
# Install Python (Windows)
# Download from python.org or use:
winget install Python.Python.3.11

# Create virtual environment
python -m venv ai_ml_env

# Activate (Windows)
ai_ml_env\Scripts\activate

# Activate (Mac/Linux)
source ai_ml_env/bin/activate

# Install essential packages
pip install numpy pandas matplotlib seaborn scikit-learn jupyter

# Verify installation
python -c "import numpy; import pandas; print('Setup successful!')"
```

---

# ğŸ—ºï¸ Roadmap Overview

## Complete Journey Timeline

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                           18-MONTH JOURNEY OVERVIEW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŸ¢ BEGINNER LEVEL (Month 1-6)
â”œâ”€â”€ Month 1: Mathematics Foundation
â”œâ”€â”€ Month 2: Python Programming
â”œâ”€â”€ Month 3: Data Analysis & Visualization
â”œâ”€â”€ Month 4: Machine Learning Fundamentals
â”œâ”€â”€ Month 5: Advanced ML Techniques
â””â”€â”€ Month 6: ML Projects & Consolidation

ğŸŸ¡ ADVANCED LEVEL (Month 7-12)
â”œâ”€â”€ Month 7: Deep Learning Foundation
â”œâ”€â”€ Month 8: Computer Vision (CNN)
â”œâ”€â”€ Month 9: Natural Language Processing
â”œâ”€â”€ Month 10: Transformers & BERT
â”œâ”€â”€ Month 11: Large Language Models
â””â”€â”€ Month 12: Generative AI & Advanced Topics

ğŸ”´ PROFESSIONAL LEVEL (Month 13-18)
â”œâ”€â”€ Month 13: MLOps Fundamentals
â”œâ”€â”€ Month 14: Cloud & Deployment
â”œâ”€â”€ Month 15: Azure AI & .NET Integration
â”œâ”€â”€ Month 16: Enterprise AI Solutions
â”œâ”€â”€ Month 17: Specialization & Portfolio
â””â”€â”€ Month 18: Job Preparation

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## Skills Progression

```
Month   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
        â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
Math    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
Python  â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
ML      â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
DL      â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
NLP/LLM â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
MLOps   â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
```

---

# ğŸŸ¢ BEGINNER LEVEL (Month 1-6)

## Learning Objectives

```
By completing Beginner Level, you will:

âœ“ Understand linear algebra, statistics, and probability
âœ“ Master Python programming for data science
âœ“ Perform exploratory data analysis
âœ“ Build and evaluate ML models
âœ“ Use scikit-learn proficiently
âœ“ Complete 5+ projects
âœ“ Have strong foundation for deep learning
```

---

## Month 1: Mathematics Foundation

### Overview

| Week | Focus | Hours | Outcome |
|------|-------|-------|---------|
| 1 | Linear Algebra Basics | 15-20 | Vector & matrix operations |
| 2 | Linear Algebra Advanced | 15-20 | Eigenvalues, decomposition |
| 3 | Statistics & Probability I | 15-20 | Descriptive stats, probability |
| 4 | Statistics & Probability II | 15-20 | Distributions, hypothesis testing |

---

### Week 1: Linear Algebra Basics

#### Daily Schedule

| Day | Topic | Time | Activities |
|-----|-------|------|------------|
| **Day 1** | Scalars, Vectors, Matrices | 2-3 hrs | Theory + 15 practice problems |
| **Day 2** | Vector Operations | 2-3 hrs | Addition, subtraction, scalar multiplication |
| **Day 3** | Dot Product & Cross Product | 2-3 hrs | Formulas, geometric interpretation |
| **Day 4** | Matrix Operations | 2-3 hrs | Addition, multiplication |
| **Day 5** | Matrix Properties | 2-3 hrs | Transpose, identity, inverse |
| **Day 6** | Practice & Review | 2-3 hrs | 30 practice problems |
| **Day 7** | Mini Quiz | 1-2 hrs | Self-assessment |

#### Key Concepts to Master

```
SCALARS, VECTORS & MATRICES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Scalar: Single number
        x = 5

Vector: Array of numbers (1D)
        v = [1, 2, 3]
        
        Row vector: [1, 2, 3]
        Column vector: [1]
                      [2]
                      [3]

Matrix: 2D array of numbers
        A = [1, 2, 3]
            [4, 5, 6]
            
        Shape: (rows, columns) = (2, 3)


VECTOR OPERATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Addition:       [1, 2] + [3, 4] = [4, 6]
Subtraction:    [5, 6] - [1, 2] = [4, 4]
Scalar mult:    2 Ã— [1, 2, 3] = [2, 4, 6]

Dot Product:    [1, 2] Â· [3, 4] = 1Ã—3 + 2Ã—4 = 11

Magnitude:      |[3, 4]| = âˆš(3Â² + 4Â²) = 5


MATRIX OPERATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Addition: (same dimensions required)
    [1, 2]   [5, 6]   [6, 8]
    [3, 4] + [7, 8] = [10, 12]

Multiplication: (AÃ—B requires A columns = B rows)
    [1, 2]   [5, 6]   [1Ã—5+2Ã—7, 1Ã—6+2Ã—8]   [19, 22]
    [3, 4] Ã— [7, 8] = [3Ã—5+4Ã—7, 3Ã—6+4Ã—8] = [43, 50]

Transpose:
    [1, 2, 3]áµ€   [1, 4]
    [4, 5, 6]  = [2, 5]
                 [3, 6]
```

#### Practice Problems

```
PROBLEM SET - WEEK 1
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Calculate: [2, 3, 4] + [1, 0, -1]

2. Calculate: 3 Ã— [1, 2, 3, 4]

3. Calculate dot product: [1, 2, 3] Â· [4, 5, 6]

4. Calculate magnitude: |[3, 4, 12]|

5. Multiply matrices:
   [1, 2]   [5, 6]
   [3, 4] Ã— [7, 8]

6. Find transpose:
   [1, 2, 3]
   [4, 5, 6]

7. Can these matrices be multiplied? Why?
   A: 3Ã—4 matrix
   B: 2Ã—3 matrix

8. Calculate: 
   [2, 0]   [1, 3]
   [1, 4] + [0, 2]

ANSWERS:
1. [3, 3, 3]
2. [3, 6, 9, 12]
3. 4+10+18 = 32
4. âˆš(9+16+144) = âˆš169 = 13
5. [[19, 22], [43, 50]]
6. [[1, 4], [2, 5], [3, 6]]
7. No. A columns (4) â‰  B rows (2)
8. [[3, 3], [1, 6]]
```

#### Resources

| Resource | Type | Link | Priority |
|----------|------|------|----------|
| 3Blue1Brown: Essence of Linear Algebra | Video Series | [YouTube](https://youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab) | â­â­â­â­â­ |
| Khan Academy: Linear Algebra | Course | [Khan Academy](https://www.khanacademy.org/math/linear-algebra) | â­â­â­â­â­ |
| Mathematics for Machine Learning | Book | [Free PDF](https://mml-book.github.io/) | â­â­â­â­ |
| MIT 18.06 Linear Algebra | Lectures | [MIT OCW](https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/) | â­â­â­ |

#### Week 1 Checklist

```
â–¡ Watched 3Blue1Brown videos 1-5
â–¡ Completed Khan Academy exercises
â–¡ Can multiply matrices by hand
â–¡ Understand dot product geometrically
â–¡ Solved 50+ practice problems
â–¡ Completed mini quiz with 80%+ score
```

---

### Week 2: Linear Algebra Advanced

#### Daily Schedule

| Day | Topic | Time | Activities |
|-----|-------|------|------------|
| **Day 1** | Linear Independence | 2-3 hrs | Theory + practice |
| **Day 2** | Span and Basis | 2-3 hrs | Vector spaces |
| **Day 3** | Eigenvalues Introduction | 2-3 hrs | Definition, calculation |
| **Day 4** | Eigenvectors | 2-3 hrs | Finding eigenvectors |
| **Day 5** | Matrix Decomposition | 2-3 hrs | SVD basics |
| **Day 6** | Applications in ML | 2-3 hrs | Why this matters |
| **Day 7** | Mini Project | 3-4 hrs | Implement from scratch |

#### Key Concepts

```
EIGENVALUES & EIGENVECTORS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Definition:
For matrix A, if Av = Î»v, then:
  â€¢ Î» (lambda) is an eigenvalue
  â€¢ v is the corresponding eigenvector

Meaning:
  â€¢ Eigenvectors: directions that don't change during transformation
  â€¢ Eigenvalues: how much stretching occurs in those directions

Finding Eigenvalues:
  det(A - Î»I) = 0
  
  For 2Ã—2 matrix [a, b]
                 [c, d]
  
  det([a-Î», b  ]) = 0
     ([c,   d-Î»])
     
  (a-Î»)(d-Î») - bc = 0
  Î»Â² - (a+d)Î» + (ad-bc) = 0


EXAMPLE:
â•â•â•â•â•â•â•

A = [4, 2]
    [1, 3]

Step 1: det(A - Î»I) = 0
        det([4-Î», 2  ]) = 0
           ([1,   3-Î»])
        
        (4-Î»)(3-Î») - 2 = 0
        12 - 4Î» - 3Î» + Î»Â² - 2 = 0
        Î»Â² - 7Î» + 10 = 0
        (Î» - 5)(Î» - 2) = 0
        
        Î»â‚ = 5, Î»â‚‚ = 2

Step 2: Find eigenvector for Î»â‚ = 5
        (A - 5I)v = 0
        [-1, 2][vâ‚]   [0]
        [1, -2][vâ‚‚] = [0]
        
        -vâ‚ + 2vâ‚‚ = 0
        vâ‚ = 2vâ‚‚
        
        Eigenvector: [2, 1] (or any scalar multiple)


WHY EIGENVALUES MATTER IN ML:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. PCA (Principal Component Analysis)
   â€¢ Eigenvectors = principal components
   â€¢ Eigenvalues = variance explained

2. PageRank Algorithm
   â€¢ Uses dominant eigenvector

3. Spectral Clustering
   â€¢ Uses eigenvectors of graph Laplacian

4. Covariance Matrix Analysis
   â€¢ Eigenvalues show feature importance
```

#### Mini Project 1: Matrix Operations Library

```python
"""
MINI PROJECT 1: Matrix Operations from Scratch
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Implement basic matrix operations WITHOUT using NumPy
This builds deep understanding of linear algebra concepts
"""

class Matrix:
    def __init__(self, data):
        """Initialize matrix with 2D list"""
        self.data = data
        self.rows = len(data)
        self.cols = len(data[0]) if data else 0
    
    def __repr__(self):
        """Pretty print matrix"""
        result = ""
        for row in self.data:
            result += "[" + ", ".join(f"{x:8.3f}" for x in row) + "]\n"
        return result
    
    def shape(self):
        """Return matrix dimensions"""
        return (self.rows, self.cols)
    
    def add(self, other):
        """Matrix addition"""
        if self.shape() != other.shape():
            raise ValueError("Matrices must have same dimensions")
        
        result = []
        for i in range(self.rows):
            row = []
            for j in range(self.cols):
                row.append(self.data[i][j] + other.data[i][j])
            result.append(row)
        return Matrix(result)
    
    def subtract(self, other):
        """Matrix subtraction"""
        if self.shape() != other.shape():
            raise ValueError("Matrices must have same dimensions")
        
        result = []
        for i in range(self.rows):
            row = []
            for j in range(self.cols):
                row.append(self.data[i][j] - other.data[i][j])
            result.append(row)
        return Matrix(result)
    
    def scalar_multiply(self, scalar):
        """Multiply matrix by scalar"""
        result = []
        for i in range(self.rows):
            row = []
            for j in range(self.cols):
                row.append(self.data[i][j] * scalar)
            result.append(row)
        return Matrix(result)
    
    def multiply(self, other):
        """Matrix multiplication"""
        if self.cols != other.rows:
            raise ValueError(f"Cannot multiply: {self.cols} != {other.rows}")
        
        result = []
        for i in range(self.rows):
            row = []
            for j in range(other.cols):
                total = 0
                for k in range(self.cols):
                    total += self.data[i][k] * other.data[k][j]
                row.append(total)
            result.append(row)
        return Matrix(result)
    
    def transpose(self):
        """Matrix transpose"""
        result = []
        for j in range(self.cols):
            row = []
            for i in range(self.rows):
                row.append(self.data[i][j])
            result.append(row)
        return Matrix(result)
    
    def dot_product(self, other):
        """Dot product for vectors (1D matrices)"""
        if self.rows != 1 or other.rows != 1:
            raise ValueError("Dot product requires 1D vectors")
        if self.cols != other.cols:
            raise ValueError("Vectors must have same length")
        
        total = 0
        for i in range(self.cols):
            total += self.data[0][i] * other.data[0][i]
        return total


class Vector:
    def __init__(self, data):
        """Initialize vector with list"""
        self.data = data
        self.size = len(data)
    
    def __repr__(self):
        return f"Vector({self.data})"
    
    def add(self, other):
        """Vector addition"""
        if self.size != other.size:
            raise ValueError("Vectors must have same size")
        return Vector([self.data[i] + other.data[i] for i in range(self.size)])
    
    def dot(self, other):
        """Dot product"""
        if self.size != other.size:
            raise ValueError("Vectors must have same size")
        return sum(self.data[i] * other.data[i] for i in range(self.size))
    
    def magnitude(self):
        """Vector magnitude (length)"""
        return sum(x**2 for x in self.data) ** 0.5
    
    def normalize(self):
        """Unit vector"""
        mag = self.magnitude()
        return Vector([x / mag for x in self.data])


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEST YOUR IMPLEMENTATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    print("=" * 50)
    print("TESTING MATRIX OPERATIONS")
    print("=" * 50)
    
    # Test Matrix Operations
    A = Matrix([[1, 2], [3, 4]])
    B = Matrix([[5, 6], [7, 8]])
    
    print("\nMatrix A:")
    print(A)
    
    print("Matrix B:")
    print(B)
    
    print("A + B:")
    print(A.add(B))
    
    print("A Ã— B:")
    print(A.multiply(B))
    
    print("A transposed:")
    print(A.transpose())
    
    print("3 Ã— A:")
    print(A.scalar_multiply(3))
    
    # Test Vector Operations
    print("=" * 50)
    print("TESTING VECTOR OPERATIONS")
    print("=" * 50)
    
    v1 = Vector([1, 2, 3])
    v2 = Vector([4, 5, 6])
    
    print(f"\nv1 = {v1}")
    print(f"v2 = {v2}")
    print(f"v1 + v2 = {v1.add(v2)}")
    print(f"v1 Â· v2 = {v1.dot(v2)}")
    print(f"|v1| = {v1.magnitude():.4f}")
    print(f"v1 normalized = {v1.normalize()}")
    
    print("\nâœ… All tests passed!")
```

#### Week 2 Checklist

```
â–¡ Understand linear independence
â–¡ Can find eigenvalues of 2Ã—2 matrix
â–¡ Can find eigenvectors
â–¡ Understand SVD conceptually
â–¡ Know why eigenvalues matter for ML
â–¡ Completed Mini Project 1
â–¡ Pushed code to GitHub
```

---

### Week 3: Statistics & Probability Part 1

#### Daily Schedule

| Day | Topic | Time | Activities |
|-----|-------|------|------------|
| **Day 1** | Descriptive Statistics | 2-3 hrs | Mean, median, mode |
| **Day 2** | Measures of Spread | 2-3 hrs | Variance, standard deviation |
| **Day 3** | Probability Basics | 2-3 hrs | Events, sample space |
| **Day 4** | Conditional Probability | 2-3 hrs | P(A\|B), independence |
| **Day 5** | Bayes Theorem | 2-3 hrs | Formula and applications |
| **Day 6** | Random Variables | 2-3 hrs | Discrete vs continuous |
| **Day 7** | Practice & Quiz | 2-3 hrs | Problem solving |

#### Key Concepts

```
DESCRIPTIVE STATISTICS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Central Tendency:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Mean (Average):     Î¼ = Î£xáµ¢ / n
Median:             Middle value when sorted
Mode:               Most frequent value

Example: Data = [2, 3, 3, 4, 5, 6, 100]
         Mean = 123/7 = 17.57  (affected by outlier)
         Median = 4            (robust to outliers)
         Mode = 3              (most frequent)


Measures of Spread:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Range:              max - min
Variance:           ÏƒÂ² = Î£(xáµ¢ - Î¼)Â² / n
Standard Deviation: Ïƒ = âˆšvariance
IQR:                Q3 - Q1 (interquartile range)

Example: Data = [2, 4, 4, 4, 5, 5, 7, 9]
         Mean (Î¼) = 40/8 = 5
         
         Variance = [(2-5)Â² + (4-5)Â² + (4-5)Â² + (4-5)Â² + 
                     (5-5)Â² + (5-5)Â² + (7-5)Â² + (9-5)Â²] / 8
                  = [9 + 1 + 1 + 1 + 0 + 0 + 4 + 16] / 8
                  = 32/8 = 4
         
         Std Dev = âˆš4 = 2


PROBABILITY BASICS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Sample Space (S): All possible outcomes
Event (E):        Subset of sample space

Probability:      P(E) = favorable outcomes / total outcomes
                  0 â‰¤ P(E) â‰¤ 1

Example: Rolling a die
         S = {1, 2, 3, 4, 5, 6}
         P(even number) = P({2, 4, 6}) = 3/6 = 0.5


RULES:
â”€â”€â”€â”€â”€â”€
Addition Rule:      P(A âˆª B) = P(A) + P(B) - P(A âˆ© B)
Multiplication:     P(A âˆ© B) = P(A) Ã— P(B|A)
Complement:         P(not A) = 1 - P(A)


CONDITIONAL PROBABILITY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

P(A|B) = P(A âˆ© B) / P(B)

"Probability of A given B has occurred"

Example:
  Card drawn from deck
  P(King | Face card) = P(King âˆ© Face) / P(Face)
                      = (4/52) / (12/52)
                      = 4/12 = 1/3


BAYES THEOREM
â•â•â•â•â•â•â•â•â•â•â•â•â•

         P(B|A) Ã— P(A)
P(A|B) = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
             P(B)

Or expanded:
                    P(B|A) Ã— P(A)
P(A|B) = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         P(B|A) Ã— P(A) + P(B|not A) Ã— P(not A)


Example: Medical Test
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Disease prevalence: 1% (P(D) = 0.01)
Test sensitivity:   99% (P(+|D) = 0.99)
Test specificity:   95% (P(-|no D) = 0.95)

If test is positive, what's probability of disease?

P(D|+) = P(+|D) Ã— P(D) / P(+)
       = P(+|D) Ã— P(D) / [P(+|D)Ã—P(D) + P(+|no D)Ã—P(no D)]
       = 0.99 Ã— 0.01 / [0.99Ã—0.01 + 0.05Ã—0.99]
       = 0.0099 / [0.0099 + 0.0495]
       = 0.0099 / 0.0594
       â‰ˆ 0.167 or 16.7%

Key insight: Even with 99% accuracy, positive test 
             only means 16.7% chance of disease!
```

#### Week 3 Checklist

```
â–¡ Can calculate mean, median, mode
â–¡ Can calculate variance and std dev
â–¡ Understand probability rules
â–¡ Can apply conditional probability
â–¡ Can use Bayes theorem
â–¡ Solved 30+ probability problems
â–¡ Watched StatQuest videos
```

---

### Week 4: Statistics & Probability Part 2

#### Daily Schedule

| Day | Topic | Time | Activities |
|-----|-------|------|------------|
| **Day 1** | Probability Distributions | 2-3 hrs | Overview of distributions |
| **Day 2** | Normal Distribution | 2-3 hrs | Properties, z-scores |
| **Day 3** | Other Distributions | 2-3 hrs | Binomial, Poisson |
| **Day 4** | Central Limit Theorem | 2-3 hrs | Concept and importance |
| **Day 5** | Hypothesis Testing | 2-3 hrs | Null/alternative hypothesis |
| **Day 6** | P-values & Confidence | 2-3 hrs | Statistical significance |
| **Day 7** | Mini Project 2 | 3-4 hrs | Statistical analysis |

#### Key Concepts

```
PROBABILITY DISTRIBUTIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Discrete Distributions:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. BINOMIAL
   â€¢ n independent trials
   â€¢ Two outcomes (success/failure)
   â€¢ P(X = k) = C(n,k) Ã— p^k Ã— (1-p)^(n-k)
   
   Example: 10 coin flips, P(exactly 7 heads)
            = C(10,7) Ã— 0.5^7 Ã— 0.5^3
            = 120 Ã— 0.0078 Ã— 0.125
            = 0.117

2. POISSON
   â€¢ Events over time/space
   â€¢ P(X = k) = (Î»^k Ã— e^(-Î»)) / k!
   
   Example: Average 3 emails/hour
            P(5 emails in an hour)
            = (3^5 Ã— e^(-3)) / 5!
            = 0.101


Continuous Distributions:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

NORMAL (GAUSSIAN)
â€¢ Bell-shaped curve
â€¢ Defined by Î¼ (mean) and Ïƒ (std dev)
â€¢ 68% within 1Ïƒ, 95% within 2Ïƒ, 99.7% within 3Ïƒ

         1            (x-Î¼)Â²
f(x) = â”€â”€â”€â”€â”€â”€ Ã— exp(- â”€â”€â”€â”€â”€)
       Ïƒâˆš(2Ï€)          2ÏƒÂ²

Z-Score: How many std devs from mean
         z = (x - Î¼) / Ïƒ


CENTRAL LIMIT THEOREM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"Sample means follow normal distribution
 regardless of population distribution
 (if sample size is large enough, n â‰¥ 30)"

This is why normal distribution is so important!


HYPOTHESIS TESTING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Steps:
1. State null hypothesis (Hâ‚€) and alternative (Hâ‚)
2. Choose significance level (Î±, usually 0.05)
3. Collect data and calculate test statistic
4. Find p-value
5. Compare p-value to Î±
6. Make decision

Hâ‚€: No effect / No difference (status quo)
Hâ‚: There is an effect / difference

If p-value < Î±: Reject Hâ‚€ (statistically significant)
If p-value â‰¥ Î±: Fail to reject Hâ‚€


Example:
â”€â”€â”€â”€â”€â”€â”€â”€
Claim: New drug lowers blood pressure by 10 mmHg

Hâ‚€: Î¼ = 0 (no difference)
Hâ‚: Î¼ â‰  0 (there is a difference)

Î± = 0.05

Test result: p-value = 0.03

Since 0.03 < 0.05, we reject Hâ‚€
Conclusion: Drug has significant effect


P-VALUE
â•â•â•â•â•â•â•

"Probability of observing results at least as 
 extreme as what we got, assuming Hâ‚€ is true"

Common misinterpretation:
  âœ— P-value is NOT probability that Hâ‚€ is true
  âœ“ P-value IS probability of data given Hâ‚€


CONFIDENCE INTERVALS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

95% CI: "We are 95% confident the true parameter
        falls within this range"

For mean: xÌ„ Â± z Ã— (Ïƒ/âˆšn)

Example:
  Sample mean = 100
  Std dev = 15
  Sample size = 25
  
  95% CI = 100 Â± 1.96 Ã— (15/âˆš25)
         = 100 Â± 1.96 Ã— 3
         = 100 Â± 5.88
         = (94.12, 105.88)
```

#### Mini Project 2: Statistical Analysis

```python
"""
MINI PROJECT 2: Statistical Analysis
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Perform complete statistical analysis on a dataset
"""

import random
import math

class StatisticalAnalyzer:
    def __init__(self, data):
        self.data = sorted(data)
        self.n = len(data)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DESCRIPTIVE STATISTICS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def mean(self):
        """Calculate arithmetic mean"""
        return sum(self.data) / self.n
    
    def median(self):
        """Calculate median"""
        mid = self.n // 2
        if self.n % 2 == 0:
            return (self.data[mid - 1] + self.data[mid]) / 2
        return self.data[mid]
    
    def mode(self):
        """Calculate mode (most frequent value)"""
        frequency = {}
        for value in self.data:
            frequency[value] = frequency.get(value, 0) + 1
        max_freq = max(frequency.values())
        modes = [k for k, v in frequency.items() if v == max_freq]
        return modes[0] if len(modes) == 1 else modes
    
    def variance(self, sample=True):
        """Calculate variance (sample or population)"""
        mean = self.mean()
        squared_diff = sum((x - mean) ** 2 for x in self.data)
        divisor = self.n - 1 if sample else self.n
        return squared_diff / divisor
    
    def std_dev(self, sample=True):
        """Calculate standard deviation"""
        return math.sqrt(self.variance(sample))
    
    def range(self):
        """Calculate range"""
        return max(self.data) - min(self.data)
    
    def quartiles(self):
        """Calculate Q1, Q2 (median), Q3"""
        q2 = self.median()
        
        mid = self.n // 2
        lower_half = self.data[:mid]
        upper_half = self.data[mid + (self.n % 2):]
        
        q1 = StatisticalAnalyzer(lower_half).median() if lower_half else q2
        q3 = StatisticalAnalyzer(upper_half).median() if upper_half else q2
        
        return q1, q2, q3
    
    def iqr(self):
        """Calculate interquartile range"""
        q1, q2, q3 = self.quartiles()
        return q3 - q1
    
    def detect_outliers(self):
        """Detect outliers using IQR method"""
        q1, q2, q3 = self.quartiles()
        iqr = q3 - q1
        lower_bound = q1 - 1.5 * iqr
        upper_bound = q3 + 1.5 * iqr
        
        outliers = [x for x in self.data if x < lower_bound or x > upper_bound]
        return outliers, lower_bound, upper_bound
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PROBABILITY & DISTRIBUTIONS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def z_score(self, x):
        """Calculate z-score for a value"""
        return (x - self.mean()) / self.std_dev()
    
    def z_scores_all(self):
        """Calculate z-scores for all data points"""
        mean = self.mean()
        std = self.std_dev()
        return [(x - mean) / std for x in self.data]
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # HYPOTHESIS TESTING
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def t_statistic(self, population_mean):
        """Calculate t-statistic for one-sample t-test"""
        sample_mean = self.mean()
        sample_std = self.std_dev()
        standard_error = sample_std / math.sqrt(self.n)
        return (sample_mean - population_mean) / standard_error
    
    def confidence_interval(self, confidence=0.95):
        """Calculate confidence interval for mean"""
        # Using z-score approximation for large samples
        z_scores = {0.90: 1.645, 0.95: 1.96, 0.99: 2.576}
        z = z_scores.get(confidence, 1.96)
        
        mean = self.mean()
        margin = z * (self.std_dev() / math.sqrt(self.n))
        
        return (mean - margin, mean + margin)
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SUMMARY REPORT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def summary(self):
        """Generate complete statistical summary"""
        q1, q2, q3 = self.quartiles()
        outliers, lb, ub = self.detect_outliers()
        ci_low, ci_high = self.confidence_interval()
        
        report = f"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    STATISTICAL SUMMARY REPORT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Sample Size: {self.n}

CENTRAL TENDENCY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Mean:   {self.mean():.4f}
Median: {self.median():.4f}
Mode:   {self.mode()}

DISPERSION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Range:              {self.range():.4f}
Variance (sample):  {self.variance():.4f}
Std Dev (sample):   {self.std_dev():.4f}
IQR:                {self.iqr():.4f}

QUARTILES
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Q1 (25%): {q1:.4f}
Q2 (50%): {q2:.4f}
Q3 (75%): {q3:.4f}

OUTLIERS (IQR Method)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Lower Bound: {lb:.4f}
Upper Bound: {ub:.4f}
Outliers:    {outliers if outliers else 'None detected'}

CONFIDENCE INTERVAL (95%)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
({ci_low:.4f}, {ci_high:.4f})

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        return report


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROBABILITY FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def factorial(n):
    """Calculate n!"""
    if n <= 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def combinations(n, k):
    """Calculate C(n, k) = n! / (k! * (n-k)!)"""
    return factorial(n) // (factorial(k) * factorial(n - k))

def binomial_probability(n, k, p):
    """P(X = k) for binomial distribution"""
    return combinations(n, k) * (p ** k) * ((1 - p) ** (n - k))

def poisson_probability(lambd, k):
    """P(X = k) for Poisson distribution"""
    e = math.e
    return ((lambd ** k) * (e ** (-lambd))) / factorial(k)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEST THE IMPLEMENTATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    
    # Generate sample data (simulating exam scores)
    random.seed(42)
    exam_scores = [random.gauss(75, 10) for _ in range(100)]
    exam_scores = [max(0, min(100, score)) for score in exam_scores]  # Bound to 0-100
    
    # Create analyzer
    analyzer = StatisticalAnalyzer(exam_scores)
    
    # Print summary
    print(analyzer.summary())
    
    # Additional analysis
    print("\nADDITIONAL ANALYSIS")
    print("=" * 60)
    
    # Z-score for a specific value
    test_score = 90
    z = analyzer.z_score(test_score)
    print(f"\nZ-score for score of {test_score}: {z:.4f}")
    print(f"This score is {abs(z):.2f} standard deviations {'above' if z > 0 else 'below'} the mean")
    
    # T-statistic
    hypothesized_mean = 70
    t = analyzer.t_statistic(hypothesized_mean)
    print(f"\nT-statistic (Hâ‚€: Î¼ = {hypothesized_mean}): {t:.4f}")
    
    # Probability calculations
    print("\n\nPROBABILITY EXAMPLES")
    print("=" * 60)
    
    # Binomial: 10 coin flips, probability of exactly 7 heads
    p = binomial_probability(10, 7, 0.5)
    print(f"\nBinomial: P(7 heads in 10 flips) = {p:.4f}")
    
    # Poisson: Average 3 emails/hour, probability of 5 emails
    p = poisson_probability(3, 5)
    print(f"Poisson: P(5 emails | Î»=3/hour) = {p:.4f}")
    
    print("\nâœ… Statistical analysis complete!")
```

#### Month 1 Final Checklist

```
MONTH 1 COMPLETION CHECKLIST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Linear Algebra:
â–¡ Vector operations (add, subtract, dot product)
â–¡ Matrix operations (multiply, transpose, inverse)
â–¡ Eigenvalues and eigenvectors
â–¡ Understanding of linear transformations
â–¡ Mini Project 1 completed

Statistics & Probability:
â–¡ Descriptive statistics (mean, median, mode, variance)
â–¡ Probability rules
â–¡ Conditional probability
â–¡ Bayes theorem
â–¡ Probability distributions
â–¡ Hypothesis testing basics
â–¡ Mini Project 2 completed

General:
â–¡ Watched all recommended videos
â–¡ Solved 100+ practice problems
â–¡ Both mini projects on GitHub
â–¡ Ready for Python month!

SELF-ASSESSMENT QUIZ: Score 80%+ to proceed
```

---

## Month 2: Python Programming

### Overview

| Week | Focus | Hours | Outcome |
|------|-------|-------|---------|
| 5 | Python Basics | 20-25 | Core syntax, data structures |
| 6 | NumPy | 15-20 | Array operations |
| 7 | Pandas | 20-25 | Data manipulation |
| 8 | Visualization | 15-20 | Matplotlib, Seaborn |

---

### Week 5: Python Basics

#### Daily Schedule

| Day | Topic | Time | Practice |
|-----|-------|------|----------|
| **Day 1** | Setup & Syntax | 3-4 hrs | Install, variables, operators |
| **Day 2** | Data Structures | 3-4 hrs | Lists, tuples, dicts, sets |
| **Day 3** | Control Flow | 3-4 hrs | if/else, loops, comprehensions |
| **Day 4** | Functions | 3-4 hrs | def, args, kwargs, lambda |
| **Day 5** | OOP | 3-4 hrs | Classes, inheritance |
| **Day 6** | File Handling | 2-3 hrs | Read/write, CSV, JSON |
| **Day 7** | Practice Projects | 3-4 hrs | Build small programs |

#### C# to Python Quick Reference

```python
"""
C# to Python Quick Reference for .NET Developers
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VARIABLES & TYPES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# C#:  int number = 10;
# Python:
number = 10  # No type declaration needed

# C#:  string name = "John";
# Python:
name = "John"

# C#:  bool isActive = true;
# Python:
is_active = True  # Note: True/False capitalized

# C#:  var items = new List<int> { 1, 2, 3 };
# Python:
items = [1, 2, 3]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA STRUCTURES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# List (like List<T>)
my_list = [1, 2, 3, 4, 5]
my_list.append(6)         # Add
my_list.remove(3)         # Remove by value
my_list.pop(0)            # Remove by index
my_list[0]                # Access by index
len(my_list)              # Count

# Dictionary (like Dictionary<K,V>)
my_dict = {"name": "John", "age": 30}
my_dict["city"] = "NYC"   # Add/update
my_dict.get("name")       # Get with default
del my_dict["age"]        # Remove

# Tuple (immutable list)
my_tuple = (1, 2, 3)      # Cannot modify after creation

# Set (unique values)
my_set = {1, 2, 3, 3}     # Results in {1, 2, 3}
my_set.add(4)
my_set.remove(1)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONTROL FLOW
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# C#:  if (x > 0) { } else if (x < 0) { } else { }
# Python:
x = 5
if x > 0:
    print("Positive")
elif x < 0:
    print("Negative")
else:
    print("Zero")

# C#:  for (int i = 0; i < 10; i++) { }
# Python:
for i in range(10):
    print(i)

# C#:  foreach (var item in items) { }
# Python:
for item in items:
    print(item)

# C#:  while (condition) { }
# Python:
while condition:
    # do something
    pass

# C#:  items.Where(x => x > 5).Select(x => x * 2)
# Python (List Comprehension - like LINQ):
result = [x * 2 for x in items if x > 5]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# C#:  public int Add(int a, int b) { return a + b; }
# Python:
def add(a, b):
    return a + b

# Default parameters
def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

# *args (variable arguments)
def sum_all(*args):
    return sum(args)

sum_all(1, 2, 3, 4, 5)  # Returns 15

# **kwargs (keyword arguments)
def create_user(**kwargs):
    return kwargs

create_user(name="John", age=30)  # Returns {'name': 'John', 'age': 30}

# Lambda (like arrow functions)
# C#:  Func<int, int, int> add = (a, b) => a + b;
# Python:
add_lambda = lambda a, b: a + b


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLASSES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# C#:
# public class Person {
#     public string Name { get; set; }
#     public Person(string name) { Name = name; }
#     public void Greet() { Console.WriteLine($"Hello, {Name}"); }
# }

# Python:
class Person:
    def __init__(self, name):
        self.name = name  # No private/public keywords
    
    def greet(self):
        print(f"Hello, {self.name}")
    
    def __str__(self):  # Like ToString()
        return f"Person: {self.name}"
    
    @property  # Like C# property
    def name_upper(self):
        return self.name.upper()

# Usage
person = Person("John")
person.greet()

# Inheritance
class Employee(Person):
    def __init__(self, name, employee_id):
        super().__init__(name)
        self.employee_id = employee_id


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STRING FORMATTING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name = "John"
age = 30

# C#:  $"Name: {name}, Age: {age}"
# Python (f-strings):
message = f"Name: {name}, Age: {age}"

# Format specifiers
pi = 3.14159
print(f"Pi: {pi:.2f}")           # Pi: 3.14
print(f"Large: {1000000:,}")     # Large: 1,000,000
print(f"Percent: {0.85:.1%}")    # Percent: 85.0%


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXCEPTION HANDLING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# C#:  try { } catch (Exception ex) { } finally { }
# Python:
try:
    result = 10 / 0
except ZeroDivisionError as e:
    print(f"Error: {e}")
except Exception as e:
    print(f"General error: {e}")
finally:
    print("Cleanup")

# Raise exception (like throw)
def validate_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FILE HANDLING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Write to file
with open("file.txt", "w") as f:
    f.write("Hello, World!")

# Read from file
with open("file.txt", "r") as f:
    content = f.read()

# Read lines
with open("file.txt", "r") as f:
    lines = f.readlines()

# CSV
import csv

with open("data.csv", "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerow(["Name", "Age"])
    writer.writerow(["John", 30])

# JSON
import json

data = {"name": "John", "age": 30}
json_string = json.dumps(data)
data_back = json.loads(json_string)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# USEFUL BUILT-IN FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

numbers = [3, 1, 4, 1, 5, 9, 2, 6]

len(numbers)              # 8
sum(numbers)              # 31
min(numbers)              # 1
max(numbers)              # 9
sorted(numbers)           # [1, 1, 2, 3, 4, 5, 6, 9]
reversed(numbers)         # iterator

# Enumerate (index + value)
for i, num in enumerate(numbers):
    print(f"Index {i}: {num}")

# Zip (combine lists)
names = ["Alice", "Bob"]
ages = [25, 30]
for name, age in zip(names, ages):
    print(f"{name} is {age}")

# Map
doubled = list(map(lambda x: x * 2, numbers))

# Filter
evens = list(filter(lambda x: x % 2 == 0, numbers))

# Any / All
any([False, False, True])   # True
all([True, True, True])     # True
```

#### Week 5 Practice Exercises

```python
"""
WEEK 5 PRACTICE EXERCISES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Complete these exercises to master Python basics
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXERCISE 1: FizzBuzz
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
Print numbers 1-100
- If divisible by 3: print "Fizz"
- If divisible by 5: print "Buzz"
- If divisible by both: print "FizzBuzz"
- Otherwise: print the number
"""

def fizzbuzz():
    for i in range(1, 101):
        if i % 3 == 0 and i % 5 == 0:
            print("FizzBuzz")
        elif i % 3 == 0:
            print("Fizz")
        elif i % 5 == 0:
            print("Buzz")
        else:
            print(i)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXERCISE 2: Word Counter
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
Count frequency of each word in a text
"""

def word_counter(text):
    words = text.lower().split()
    frequency = {}
    for word in words:
        # Remove punctuation
        word = ''.join(c for c in word if c.isalnum())
        if word:
            frequency[word] = frequency.get(word, 0) + 1
    return frequency

# Test
text = "Hello world hello Python world Python Python"
print(word_counter(text))
# Output: {'hello': 2, 'world': 2, 'python': 3}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXERCISE 3: Prime Numbers
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
Generate all prime numbers up to n
"""

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def primes_up_to(n):
    return [i for i in range(2, n + 1) if is_prime(i)]

print(primes_up_to(30))
# Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXERCISE 4: List Manipulation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
Implement common list operations
"""

def flatten_list(nested_list):
    """Flatten a nested list"""
    result = []
    for item in nested_list:
        if isinstance(item, list):
            result.extend(flatten_list(item))
        else:
            result.append(item)
    return result

print(flatten_list([1, [2, 3], [4, [5, 6]], 7]))
# Output: [1, 2, 3, 4, 5, 6, 7]


def chunk_list(lst, chunk_size):
    """Split list into chunks"""
    return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]

print(chunk_list([1, 2, 3, 4, 5, 6, 7], 3))
# Output: [[1, 2, 3], [4, 5, 6], [7]]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXERCISE 5: Class Implementation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
Implement a BankAccount class
"""

class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self._balance = balance  # Protected attribute
        self.transactions = []
    
    @property
    def balance(self):
        return self._balance
    
    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        self._balance += amount
        self.transactions.append(f"Deposit: +${amount}")
        return self._balance
    
    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive")
        if amount > self._balance:
            raise ValueError("Insufficient funds")
        self._balance -= amount
        self.transactions.append(f"Withdrawal: -${amount}")
        return self._balance
    
    def get_statement(self):
        statement = f"\n{'='*40}\n"
        statement += f"Account Statement for {self.owner}\n"
        statement += f"{'='*40}\n"
        for transaction in self.transactions:
            statement += f"  {transaction}\n"
        statement += f"{'='*40}\n"
        statement += f"Current Balance: ${self._balance}\n"
        statement += f"{'='*40}\n"
        return statement
    
    def __str__(self):
        return f"BankAccount({self.owner}, Balance: ${self._balance})"


# Test
account = BankAccount("John Doe", 1000)
account.deposit(500)
account.withdraw(200)
print(account.get_statement())


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXERCISE 6: File Operations
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
Read/write CSV data
"""

import csv
import json

def create_sample_csv(filename):
    """Create a sample CSV file"""
    data = [
        ["Name", "Age", "City"],
        ["Alice", 25, "New York"],
        ["Bob", 30, "Los Angeles"],
        ["Charlie", 35, "Chicago"]
    ]
    
    with open(filename, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerows(data)

def read_csv_to_dict(filename):
    """Read CSV and return list of dictionaries"""
    with open(filename, "r") as f:
        reader = csv.DictReader(f)
        return list(reader)

def csv_to_json(csv_file, json_file):
    """Convert CSV to JSON"""
    data = read_csv_to_dict(csv_file)
    with open(json_file, "w") as f:
        json.dump(data, f, indent=2)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXERCISE 7: Decorators (Advanced)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
Implement common decorators
"""

import time
from functools import wraps

def timer(func):
    """Decorator to measure function execution time"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

def retry(max_attempts=3):
    """Decorator to retry function on failure"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"Attempt {attempt + 1} failed: {e}")
                    if attempt == max_attempts - 1:
                        raise
        return wrapper
    return decorator

@timer
def slow_function():
    time.sleep(1)
    return "Done"

@retry(max_attempts=3)
def unreliable_function():
    import random
    if random.random() < 0.7:
        raise Exception("Random failure")
    return "Success"
```

---

### Week 6: NumPy Mastery

#### Daily Schedule

| Day | Topic | Time | Practice |
|-----|-------|------|----------|
| **Day 1** | Array Creation | 2-3 hrs | Creating arrays, dtypes |
| **Day 2** | Indexing & Slicing | 3-4 hrs | Advanced indexing |
| **Day 3** | Array Operations | 3-4 hrs | Broadcasting, vectorization |
| **Day 4** | Math Functions | 2-3 hrs | Statistical, algebraic |
| **Day 5** | Reshaping | 2-3 hrs | reshape, flatten, stack |
| **Day 6** | Linear Algebra | 2-3 hrs | np.linalg module |
| **Day 7** | Practice Project | 3-4 hrs | NumPy implementation |

#### Complete NumPy Guide

```python
"""
COMPLETE NUMPY GUIDE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Master NumPy for Machine Learning
"""

import numpy as np

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 1. ARRAY CREATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# From Python list
arr = np.array([1, 2, 3, 4, 5])
matrix = np.array([[1, 2, 3], [4, 5, 6]])

# Special arrays
zeros = np.zeros((3, 4))           # 3x4 matrix of zeros
ones = np.ones((2, 3))             # 2x3 matrix of ones
full = np.full((2, 2), 7)          # 2x2 matrix filled with 7
identity = np.eye(4)               # 4x4 identity matrix
empty = np.empty((2, 3))           # Uninitialized (fast)

# Ranges
range_arr = np.arange(0, 10, 2)    # [0, 2, 4, 6, 8]
linspace = np.linspace(0, 1, 5)   # [0, 0.25, 0.5, 0.75, 1.0]
logspace = np.logspace(0, 2, 3)   # [1, 10, 100]

# Random arrays
random_uniform = np.random.rand(3, 3)        # Uniform [0, 1)
random_normal = np.random.randn(3, 3)        # Standard normal
random_int = np.random.randint(0, 10, (3, 3)) # Random integers
random_choice = np.random.choice([1, 2, 3], 10) # Random selection

# Data types
arr_float = np.array([1, 2, 3], dtype=np.float32)
arr_int = np.array([1.5, 2.5, 3.5], dtype=np.int32)  # Truncates

print(f"Shape: {arr.shape}")
print(f"Dtype: {arr.dtype}")
print(f"Ndim: {arr.ndim}")
print(f"Size: {arr.size}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 2. INDEXING & SLICING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

arr = np.array([[1, 2, 3, 4],
                [5, 6, 7, 8],
                [9, 10, 11, 12]])

# Basic indexing
arr[0]           # First row: [1, 2, 3, 4]
arr[0, 1]        # Element at row 0, col 1: 2
arr[-1]          # Last row: [9, 10, 11, 12]
arr[-1, -1]      # Last element: 12

# Slicing [start:stop:step]
arr[0:2]         # Rows 0 and 1
arr[:, 1]        # All rows, column 1: [2, 6, 10]
arr[1:, 1:3]     # Rows 1+, columns 1-2
arr[::2]         # Every other row

# Fancy indexing
indices = [0, 2]
arr[indices]     # Rows 0 and 2

# Boolean indexing
mask = arr > 5
arr[mask]        # All elements > 5: [6, 7, 8, 9, 10, 11, 12]
arr[arr > 5]     # Same thing

# Where
np.where(arr > 5, arr, 0)   # Replace values <= 5 with 0


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 3. ARRAY OPERATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

a = np.array([1, 2, 3, 4])
b = np.array([5, 6, 7, 8])

# Element-wise operations
a + b            # [6, 8, 10, 12]
a - b            # [-4, -4, -4, -4]
a * b            # [5, 12, 21, 32]
a / b            # [0.2, 0.33, 0.43, 0.5]
a ** 2           # [1, 4, 9, 16]
np.sqrt(a)       # [1, 1.41, 1.73, 2]
np.exp(a)        # e^a
np.log(a)        # natural log
np.sin(a)        # sine

# Broadcasting
matrix = np.array([[1, 2, 3],
                   [4, 5, 6]])
vector = np.array([10, 20, 30])
matrix + vector  # Adds vector to each row
# [[11, 22, 33],
#  [14, 25, 36]]

# Aggregations
arr = np.array([[1, 2, 3],
                [4, 5, 6]])

np.sum(arr)          # 21 (all elements)
np.sum(arr, axis=0)  # [5, 7, 9] (column sums)
np.sum(arr, axis=1)  # [6, 15] (row sums)
np.mean(arr)         # 3.5
np.std(arr)          # Standard deviation
np.var(arr)          # Variance
np.min(arr)          # 1
np.max(arr)          # 6
np.argmin(arr)       # Index of min: 0
np.argmax(arr)       # Index of max: 5
np.cumsum(arr)       # Cumulative sum


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 4. RESHAPING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

arr = np.arange(12)  # [0, 1, 2, ..., 11]

# Reshape
arr.reshape(3, 4)    # 3 rows, 4 columns
arr.reshape(2, -1)   # 2 rows, auto-calculate columns
arr.reshape(-1, 1)   # Column vector

# Flatten
matrix = np.array([[1, 2], [3, 4]])
matrix.flatten()     # [1, 2, 3, 4]
matrix.ravel()       # Same, but view (more efficient)

# Transpose
matrix.T             # [[1, 3], [2, 4]]

# Stacking
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
np.vstack([a, b])    # Vertical stack: [[1,2,3], [4,5,6]]
np.hstack([a, b])    # Horizontal stack: [1,2,3,4,5,6]
np.column_stack([a, b])  # As columns: [[1,4], [2,5], [3,6]]

# Splitting
arr = np.arange(9)
np.split(arr, 3)     # Three equal parts
np.array_split(arr, 4)  # Allows unequal parts


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 5. LINEAR ALGEBRA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# Matrix multiplication
np.dot(A, B)         # Matrix product
A @ B                # Same thing (Python 3.5+)
np.matmul(A, B)      # Same thing

# Element-wise multiplication (NOT matrix mult)
A * B                # [[5, 12], [21, 32]]

# Determinant
np.linalg.det(A)     # -2.0

# Inverse
np.linalg.inv(A)     # [[-2, 1], [1.5, -0.5]]

# Eigenvalues and eigenvectors
eigenvalues, eigenvectors = np.linalg.eig(A)

# Solve linear system Ax = b
b = np.array([1, 2])
x = np.linalg.solve(A, b)

# Singular Value Decomposition
U, S, Vt = np.linalg.svd(A)

# Norms
np.linalg.norm(A)           # Frobenius norm
np.linalg.norm(A, ord=1)    # L1 norm
np.linalg.norm(A, ord=np.inf)  # Max norm


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 6. PRACTICAL EXAMPLES FOR ML
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Example 1: Normalize data (feature scaling)
def normalize(X):
    """Min-max normalization to [0, 1]"""
    X_min = X.min(axis=0)
    X_max = X.max(axis=0)
    return (X - X_min) / (X_max - X_min)

def standardize(X):
    """Z-score standardization"""
    mean = X.mean(axis=0)
    std = X.std(axis=0)
    return (X - mean) / std


# Example 2: Calculate distance matrix
def euclidean_distance_matrix(X):
    """Calculate pairwise Euclidean distances"""
    # X shape: (n_samples, n_features)
    diff = X[:, np.newaxis, :] - X[np.newaxis, :, :]
    return np.sqrt(np.sum(diff ** 2, axis=-1))


# Example 3: Softmax function
def softmax(x):
    """Compute softmax values"""
    exp_x = np.exp(x - np.max(x))  # Subtract max for numerical stability
    return exp_x / exp_x.sum()


# Example 4: One-hot encoding
def one_hot_encode(labels, num_classes):
    """Convert labels to one-hot encoding"""
    n = len(labels)
    one_hot = np.zeros((n, num_classes))
    one_hot[np.arange(n), labels] = 1
    return one_hot


# Example 5: Batch iterator
def create_batches(X, y, batch_size):
    """Create mini-batches for training"""
    n_samples = len(X)
    indices = np.random.permutation(n_samples)
    
    for start_idx in range(0, n_samples, batch_size):
        end_idx = min(start_idx + batch_size, n_samples)
        batch_indices = indices[start_idx:end_idx]
        yield X[batch_indices], y[batch_indices]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 7. NUMPY CHEAT SHEET
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ARRAY CREATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
np.array([1,2,3])       From list
np.zeros((m,n))         Zeros matrix
np.ones((m,n))          Ones matrix
np.eye(n)               Identity matrix
np.arange(start,stop)   Range array
np.linspace(0,1,n)      n evenly spaced
np.random.rand(m,n)     Uniform random
np.random.randn(m,n)    Normal random

INDEXING
â”€â”€â”€â”€â”€â”€â”€â”€
arr[i]                  Row i
arr[i,j]                Element (i,j)
arr[i:j]                Rows i to